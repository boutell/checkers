<html>
  <head>
    <title>Checkers</title>
    <style>
      h1 {
        text-align: center;
      }
      main {
        text-align: center;
      }
      #board {
        display: inline-block;
        border: 2px solid gray;
      }
      .row {
        clear: left;
      }
      .cell {
        width: 32px;
        height: 32px;
        float: left;
        padding: 2px;
        border: 2px solid gray;
      }
      .checker {
        display: inline-block;
        border-radius: 16px;
        width: 32px;
        height: 32px;
      }
      .king {
        border-radius: 14px;
        box-shadow: 0 0 0 4px blue;
      }
      .red {
        background-color: red;
      }
      .black {
        background-color: black;
      }
    </style>
  </head>
  <body>
    <h1>Checkers</h1>
    <main>
      <div id="board"></div>
    </main>
    <script>
      (function() {
        const rows = 8, cols = 8;
        const interval = 50;
        const board = [];
        const depth = 5;
        let player = 'red';
        let movesWithoutCapture = 0;
        reset();
        function nextTurn() {
          const move = findBestMove(board, player, depth);
          movesWithoutCapture++;
          if (move.move) {
            if (move.move.jumped) {
              movesWithoutCapture = 0;
            }
            applyMove(board, player, move.move);
            updateBoard();
          }
          if (player === 'red') {
            player = 'black';
          } else {
            player = 'red';
          }
          if (movesWithoutCapture === 40) {
            movesWithoutCapture = 0;
            setTimeout(reset, interval * 70);
          } else {
            setTimeout(nextTurn, interval);
          }
        }

        // It's our turn.
        // * Get list of valid moves
        // * For each valid move...
        //   * Find the score that will result after "depth" moves
        // * Return the move with the best score, along with the best score.

        function findBestMove(board, player, depth) {
          const moves = validMoves(board, player); 
          let best = false;
          let bestMove;
          if (!moves.length) {
            return {
              score: scoreBoard(board)
            };
          }
          for (const move of moves) {
            const b = cloneBoard(board);
            applyMove(b, player, move);
            let score;
            if (depth) {
              const otherMove = findBestMove(b, other(player), depth - 1);
              // We want the worst outcome for the other player as a result of our best move
              score = -otherMove.score;
            } else {
              score = scoreBoard(b, player);
            }
            if ((best === false) || (score > best)) {
              best = score;
              bestMove = move;
            }
          }
          return { move: bestMove, score: best };
        }
        function reset() {
          player = 'red';
          movesWithoutCapture = 0;
          initBoard();
          setTimeout(nextTurn, interval);
        }
        function initBoard() {
          const boardEl = document.querySelector('#board');
          let html = '';
          for (let x = 0; (x < cols); x++) {
            board[x] = [];
          }
          for (let y = 0; (y < rows); y++) {
            html += '<div class="row">';
            for (let x = 0; (x < cols); x++) {
              board[x][y] = null;
              if ((x + y) % 2) {
                if (y < 3) {
                  board[x][y] = {
                    player: 'black',
                    type: 'pawn'
                  };
                } else if (y >= (rows - 3)) {
                  board[x][y] = {
                    player: 'red',
                    type: 'pawn'
                  };
                }
              }
              html += '<div id="cell' + x + '_' + y + '" class="cell"></div>';
            }
            html += '</div>';
          }
          boardEl.innerHTML = html;
          updateBoard();
        }
        function updateBoard() {
          for (let y = 0; (y < rows); y++) {
            for (let x = 0; (x < cols); x++) {
              const cell = document.querySelector('#cell' + x + '_' + y);
              if (board[x][y]) {
                cell.innerHTML = '<div class="checker ' + board[x][y].player + ' ' + board[x][y].type + '"></div>';
              } else {
                cell.innerHTML = '';
              }
            }
          }
        }
        function applyMove(board, player, move) {
          if (!move) {
            return;
          }
          board[move.x][move.y] = {
            player: player,
            type: board[move.piece.x][move.piece.y].type
          };
          if ((player === 'black') && (move.y === rows - 1)) {
            board[move.x][move.y].type = 'king';
          } else if ((player === 'red') && (move.y === 0)) {
            board[move.x][move.y].type = 'king';
          }
          board[move.piece.x][move.piece.y] = null;
          if (move.jumped) {
            board[move.jumped.x][move.jumped.y] = null;
          }
        }
        function validMoves(board, player) {
          const pieces = [];
          for (let y = 0; (y < rows); y++) {
            for (let x = 0; (x < cols); x++) {
              if (board[x][y] && (board[x][y].player === player)) {
                pieces.push({ x, y, type: board[x][y].type }); 
              }
            }
          }
          const moves = [];
          for (piece of pieces) {
            if (piece.type === 'king') {
              test([[-1, -1], [1, -1], [-1, 1], [1, 1]]);
            } else if (player === 'red') {
              test([[-1, -1], [1, -1]]);
            } else {
              test([[-1, 1], [1, 1]]);
            }
            function test(deltas) {
              for (delta of deltas) {
                const dx = delta[0];
                const dy = delta[1];
                const value = probe(dx, dy);
                if (value === false) {
                  // out of bounds
                } else if (value === null) {
                  moves.push({ piece, x: piece.x + dx, y: piece.y + dy });
                } else if (value.player !== player) {
                  if (probe(dx * 2, dy * 2) === null) {
                    moves.push({ piece, x: piece.x + dx * 2, y: piece.y + dy * 2, jumped: { x: piece.x + dx, y: piece.y + dy } });
                  }
                }
              }
            }
            function probe(dx, dy) {
              if ((piece.x + dx >= 0) && (piece.y + dy >= 0) && (piece.x + dx < cols) && (piece.y + dy < rows)) {
                return board[piece.x + dx][piece.y + dy];
              } else {
                return false;
              }
            }
          }
          // If you can jump, you must jump
          if (moves.find(move => move.jumped)) {
            return moves.filter(move => move.jumped);
          }
          // TODO multi-step moves due to jumping, kings
          return moves;
        }
        function scoreBoard(board, player) {
          let score = 0;
          for (let y = 0; (y < rows); y++) {
            for (let x = 0; (x < cols); x++) {
              const value = board[x][y];
              if (value === null) {
                // no effect
              } else if (value.player === player) {
                score++;
              } else {
                score--;
              }
            }
          }
          return score;
        }
        function other(player) {
          if (player === 'red') {
            return 'black';
          } else {
            return 'red';
          }
        }
        function cloneBoard(board) {
          const clone = [];
          for (let x = 0; (x < cols); x++) {
            clone[x] = [];
            for (let y = 0; (y < rows); y++) {
              if (board[x][y]) {
                clone[x][y] = {
                  ...board[x][y]
                };
              } else {
                clone[x][y] = null;
              }
            }
          }
          return clone;
        }
      })();
    </script>
  </body>
</html>
